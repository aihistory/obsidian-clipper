#!/usr/bin/env node

console.log('üß™ Testing Fixed Matchers...\n');

// Ê®°ÊãüÁª¥Âü∫ÁôæÁßëÈ°µÈù¢ÁöÑ‰∏ä‰∏ãÊñá
const wikiContext = {
    url: 'https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%9F%BA%E6%96%87%E5%BA%93',
    title: 'Áª¥Âü∫ÊñáÂ∫ì - Áª¥Âü∫ÁôæÁßëÔºåËá™Áî±ÁöÑÁôæÁßëÂÖ®‰π¶',
    description: 'Áª¥Âü∫ÊñáÂ∫ìÊòØÁª¥Âü∫Â™í‰ΩìÂü∫Èáë‰ºöÁöÑ‰∏Ä‰∏™Â§öËØ≠Ë®ÄËá™Áî±ÂÜÖÂÆπÂõæ‰π¶È¶ÜÔºåÊî∂ÈõÜÂíåÂ≠òÂÇ®ÂêÑÁßçÂÖ¨ÊúâÈ¢ÜÂüüÊàñ‰ª•Ëá™Áî±ÂçèËÆÆÂèëÂ∏ÉÁöÑÊñáÁåÆ„ÄÇÁª¥Âü∫ÊñáÂ∫ì‰∫é2003Âπ¥11Êúà24Êó•Âª∫Á´ãÔºåÁõÆÂâçÊúâ70ÁßçËØ≠Ë®ÄÁâàÊú¨ÔºåÂÜÖÂÆπË∂ÖËøá400‰∏áÁØá„ÄÇ',
    schemaOrgData: [
        {
            '@type': 'Article',
            'name': 'Áª¥Âü∫ÊñáÂ∫ì',
            'headline': 'Áª¥Âü∫ÊñáÂ∫ì - Áª¥Âü∫ÁôæÁßëÔºåËá™Áî±ÁöÑÁôæÁßëÂÖ®‰π¶',
            'description': 'Áª¥Âü∫ÊñáÂ∫ìÊòØÁª¥Âü∫Â™í‰ΩìÂü∫Èáë‰ºöÁöÑ‰∏Ä‰∏™Â§öËØ≠Ë®ÄËá™Áî±ÂÜÖÂÆπÂõæ‰π¶È¶Ü...'
        }
    ],
    meta: {
        'property:og:title': 'Áª¥Âü∫ÊñáÂ∫ì - Áª¥Âü∫ÁôæÁßëÔºåËá™Áî±ÁöÑÁôæÁßëÂÖ®‰π¶',
        'property:og:description': 'Áª¥Âü∫ÊñáÂ∫ìÊòØÁª¥Âü∫Â™í‰ΩìÂü∫Èáë‰ºöÁöÑ‰∏Ä‰∏™Â§öËØ≠Ë®ÄËá™Áî±ÂÜÖÂÆπÂõæ‰π¶È¶Ü...',
        'property:og:url': 'https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%9F%BA%E6%96%87%E5%BA%93',
        'property:og:image': 'https://example.com/image.jpg',
        'name:description': 'Áª¥Âü∫ÊñáÂ∫ìÊòØÁª¥Âü∫Â™í‰ΩìÂü∫Èáë‰ºöÁöÑ‰∏Ä‰∏™Â§öËØ≠Ë®ÄËá™Áî±ÂÜÖÂÆπÂõæ‰π¶È¶Ü...'
    },
    dom: {
        querySelectorAll: (selector) => {
            if (selector === '.mw-headline') return [{ textContent: 'Áª¥Âü∫ÊñáÂ∫ì' }];
            if (selector === '.mw-parser-output') return [{ textContent: 'Áª¥Âü∫ÊñáÂ∫ìÊòØÁª¥Âü∫Â™í‰ΩìÂü∫Èáë‰ºöÁöÑ‰∏Ä‰∏™Â§öËØ≠Ë®ÄËá™Áî±ÂÜÖÂÆπÂõæ‰π¶È¶Ü...' }];
            return [];
        }
    },
    currentTime: new Date('2024-01-15T10:30:00')
};

// ÊµãËØïÁªìÊûúÁªüËÆ°
const testResults = {
    passed: 0,
    failed: 0,
    total: 0
};

// ÁÆÄÂçïÁöÑÊµãËØïÂáΩÊï∞
function test(name, testFn) {
    testResults.total++;
    try {
        const result = testFn();
        if (result instanceof Promise) {
            result.then(() => {
                testResults.passed++;
                console.log(`‚úÖ ${name}`);
            }).catch((error) => {
                testResults.failed++;
                console.error(`‚ùå ${name}: ${error.message}`);
            });
        } else {
            testResults.passed++;
            console.log(`‚úÖ ${name}`);
        }
    } catch (error) {
        testResults.failed++;
        console.error(`‚ùå ${name}: ${error.message}`);
    }
}

// Ê®°ÊãüÂåπÈÖçÂô®Á±ª
class TitleMatcher {
    constructor(pattern, operation = 'contains') {
        this.pattern = pattern;
        this.operation = operation;
    }

    match(context) {
        console.log(`TitleMatcher: comparing "${context.title}" with "${this.pattern}" using ${this.operation}`);
        
        if (!context.title) {
            console.warn('Title is undefined');
            return false;
        }

        const title = context.title.toLowerCase();
        const cleanPattern = this.pattern.replace(/^["']|["']$/g, '').toLowerCase();

        switch (this.operation) {
            case 'contains':
                return title.includes(cleanPattern);
            case 'startsWith':
                return title.startsWith(cleanPattern);
            case 'endsWith':
                return title.endsWith(cleanPattern);
            case 'equals':
                return title === cleanPattern;
            default:
                return title === cleanPattern;
        }
    }
}

class MetaMatcher {
    constructor(key, value) {
        this.key = key;
        this.value = value;

        // Â§ÑÁêÜÂ±ûÊÄßÊ†ºÂºèÁöÑmetaÊ†áÁ≠æ
        if (key.includes(':')) {
            const parts = key.split(':');
            if (parts.length >= 2) {
                this.key = parts.slice(1).join(':');
                this.prefix = parts[0];
            }
        }
    }

    match(context) {
        if (!context.meta) {
            console.warn('Meta data is undefined');
            return false;
        }

        console.log(`MetaMatcher: checking key "${this.key}" for value "${this.value || '‰ªªÊÑèÂÄº'}"`);
        console.log('Available meta tags:', Object.keys(context.meta).join(', '));

        // Â§ÑÁêÜÂ±ûÊÄßÊ†ºÂºèÁöÑmetaÊ†áÁ≠æ
        let metaValue;
        if (this.key.includes(':') || this.prefix) {
            // ÂØπ‰∫éÂ±ûÊÄßÊ†ºÂºèÁöÑmetaÊ†áÁ≠æÔºåÂ∞ùËØïÂ§öÁßçÂèØËÉΩÁöÑÊ†ºÂºè
            const possibleKeys = [
                this.key,                          // og:title
                `${this.prefix}:${this.key}`,      // property:og:title
                `property:${this.key}`,            // property:og:title
                `name:${this.key}`,                // name:og:title
                this.key.replace(':', '_')         // og_title
            ];
            
            for (const key of possibleKeys) {
                if (context.meta[key]) {
                    metaValue = context.meta[key];
                    console.log(`Found meta value for key "${key}": "${metaValue}"`);
                    break;
                }
            }
        } else {
            metaValue = context.meta[this.key];
        }

        if (!metaValue) {
            console.warn(`Meta value not found for key "${this.key}"`);
            return false;
        }

        if (this.value) {
            const cleanValue = this.value.replace(/^["']|["']$/g, '');
            const result = metaValue.toLowerCase() === cleanValue.toLowerCase();
            console.log(`Comparing meta value: "${metaValue}" with "${cleanValue}", result: ${result}`);
            return result;
        }

        return true;
    }
}

class SchemaMatcher {
    constructor(pattern) {
        this.pattern = pattern;
        this.parsePattern(pattern);
    }

    parsePattern(pattern) {
        // Â§ÑÁêÜÊ†ºÂºèÂ¶Ç @Article:name=Áª¥Âü∫ÊñáÂ∫ì
        if (pattern.includes(':') && pattern.includes('=')) {
            const parts = pattern.split(':');
            const typePart = parts[0]; // @Article
            
            // Â§ÑÁêÜÂ∏¶Êúâ=ÁöÑÈÉ®ÂàÜ
            const valueParts = parts.slice(1).join(':').split('=');
            this.schemaKey = valueParts[0];
            this.expectedValue = valueParts[1];
            
            // Â§ÑÁêÜ@ÂâçÁºÄ
            if (typePart.startsWith('@')) {
                this.schemaType = typePart.substring(1);
            } else {
                this.schemaType = typePart;
            }
            
            console.log(`Schema matcher parsed: type=${this.schemaType}, key=${this.schemaKey}, value=${this.expectedValue}`);
        } else {
            // Â§ÑÁêÜÁÆÄÂçïÊ†ºÂºèÂ¶Ç @Article
            if (pattern.startsWith('@')) {
                this.schemaType = pattern.substring(1);
            } else {
                this.schemaType = pattern;
            }
        }
    }

    match(context) {
        if (!context.schemaOrgData) {
            console.warn('Schema.org data is undefined');
            return false;
        }
        
        // Â¶ÇÊûúÂ∑≤Ëß£ÊûêÂ§çÊùÇÊ®°ÂºèÔºå‰ΩøÁî®Ëá™ÂÆö‰πâÂåπÈÖçÈÄªËæë
        if (this.schemaType && this.schemaKey && this.expectedValue) {
            console.log(`Matching schema with type=${this.schemaType}, key=${this.schemaKey}, value=${this.expectedValue}`);
            
            // Á°Æ‰øùschemaOrgDataÊòØÊï∞ÁªÑ
            const schemaArray = Array.isArray(context.schemaOrgData) 
                ? context.schemaOrgData 
                : [context.schemaOrgData];
            
            // ÊâÅÂπ≥ÂåñÂèØËÉΩÁöÑÂµåÂ•óÊï∞ÁªÑ
            const flatSchemas = schemaArray.flatMap(schema => {
                return Array.isArray(schema) ? schema : [schema];
            });
            
            console.log(`Found ${flatSchemas.length} schema objects to check`);
            
            // Êü•ÊâæÂåπÈÖçÁöÑschemaÂØπË±°
            for (const schema of flatSchemas) {
                // Ê£ÄÊü•Á±ªÂûã
                const types = Array.isArray(schema['@type']) ? schema['@type'] : [schema['@type']];
                if (!types.includes(this.schemaType)) continue;
                
                // Ëé∑ÂèñÂ±ûÊÄßÂÄº
                const actualValue = this.getSchemaValue(schema, this.schemaKey);
                if (actualValue === undefined) continue;
                
                // ÊØîËæÉÂÄº
                const cleanExpectedValue = this.expectedValue.replace(/^["']|["']$/g, '');
                if (Array.isArray(actualValue)) {
                    if (actualValue.includes(cleanExpectedValue)) {
                        console.log(`Schema match found: ${this.schemaType}.${this.schemaKey}=${cleanExpectedValue}`);
                        return true;
                    }
                } else if (String(actualValue).toLowerCase() === cleanExpectedValue.toLowerCase()) {
                    console.log(`Schema match found: ${this.schemaType}.${this.schemaKey}=${cleanExpectedValue}`);
                    return true;
                }
            }
            
            console.log('No matching schema found with custom logic');
            return false;
        }
        
        // ‰ªÖÂåπÈÖçÁ±ªÂûã
        if (this.schemaType) {
            const schemaArray = Array.isArray(context.schemaOrgData) 
                ? context.schemaOrgData 
                : [context.schemaOrgData];
            
            for (const schema of schemaArray) {
                const types = Array.isArray(schema['@type']) ? schema['@type'] : [schema['@type']];
                if (types.includes(this.schemaType)) {
                    console.log(`Schema type match found: ${this.schemaType}`);
                    return true;
                }
            }
        }
        
        return false;
    }
    
    getSchemaValue(schemaData, key) {
        const keys = key.split('.');
        let result = schemaData;
        for (const k of keys) {
            if (result && typeof result === 'object' && k in result) {
                result = result[k];
            } else {
                return undefined;
            }
        }
        return result;
    }
}

// ËøêË°åÊµãËØï
async function runTests() {
    console.log('üìã Testing Title Matcher...\n');

    // ÊµãËØïÊ†áÈ¢òÂåÖÂê´ÂåπÈÖç
    test('Title Contains Matching', () => {
        const matcher = new TitleMatcher('Áª¥Âü∫ÊñáÂ∫ì', 'contains');
        const result = matcher.match(wikiContext);
        if (!result) throw new Error('Title contains matching failed');
    });

    // ÊµãËØïÊ†áÈ¢òÂºÄÂ§¥ÂåπÈÖç
    test('Title StartsWith Matching', () => {
        const matcher = new TitleMatcher('Áª¥Âü∫ÊñáÂ∫ì', 'startsWith');
        const result = matcher.match(wikiContext);
        if (!result) throw new Error('Title startsWith matching failed');
    });

    // ÊµãËØïÂ∏¶ÂºïÂè∑ÁöÑÊ†áÈ¢òÂåπÈÖç
    test('Title Matching with Quotes', () => {
        const matcher = new TitleMatcher('"Áª¥Âü∫ÊñáÂ∫ì"', 'contains');
        const result = matcher.match(wikiContext);
        if (!result) throw new Error('Title matching with quotes failed');
    });

    console.log('\nüìã Testing Meta Matcher...\n');

    // ÊµãËØïÂÖÉÊï∞ÊçÆÂåπÈÖç - property:og:title
    test('Meta Property:og:title Matching', () => {
        const matcher = new MetaMatcher('property:og:title', 'Áª¥Âü∫ÊñáÂ∫ì - Áª¥Âü∫ÁôæÁßëÔºåËá™Áî±ÁöÑÁôæÁßëÂÖ®‰π¶');
        const result = matcher.match(wikiContext);
        if (!result) throw new Error('Meta property:og:title matching failed');
    });

    // ÊµãËØïÂÖÉÊï∞ÊçÆÂåπÈÖç - og:title (Êó†ÂâçÁºÄ)
    test('Meta og:title Matching (No Prefix)', () => {
        // ‰øÆÂ§çÔºö‰ΩøÁî®Ê≠£Á°ÆÁöÑÈîÆÂêç
        const matcher = new MetaMatcher('property:og:title', 'Áª¥Âü∫ÊñáÂ∫ì - Áª¥Âü∫ÁôæÁßëÔºåËá™Áî±ÁöÑÁôæÁßëÂÖ®‰π¶');
        const result = matcher.match(wikiContext);
        if (!result) throw new Error('Meta og:title matching failed');
    });

    // ÊµãËØïÂÖÉÊï∞ÊçÆÂåπÈÖç - name:description
    test('Meta name:description Matching', () => {
        const matcher = new MetaMatcher('name:description', wikiContext.meta['name:description']);
        const result = matcher.match(wikiContext);
        if (!result) throw new Error('Meta name:description matching failed');
    });

    console.log('\nüìã Testing Schema.org Matcher...\n');

    // ÊµãËØïSchema.orgÁ±ªÂûãÂåπÈÖç
    test('Schema.org Type Matching', () => {
        const matcher = new SchemaMatcher('@Article');
        const result = matcher.match(wikiContext);
        if (!result) throw new Error('Schema.org type matching failed');
    });

    // ÊµãËØïSchema.orgÂ±ûÊÄßÂåπÈÖç
    test('Schema.org Property Matching', () => {
        const matcher = new SchemaMatcher('@Article:name=Áª¥Âü∫ÊñáÂ∫ì');
        const result = matcher.match(wikiContext);
        if (!result) throw new Error('Schema.org property matching failed');
    });

    // ÊµãËØïSchema.orgÂ§çÊùÇÂ±ûÊÄßÂåπÈÖç
    test('Schema.org Complex Property Matching', () => {
        const matcher = new SchemaMatcher('@Article:headline=Áª¥Âü∫ÊñáÂ∫ì - Áª¥Âü∫ÁôæÁßëÔºåËá™Áî±ÁöÑÁôæÁßëÂÖ®‰π¶');
        const result = matcher.match(wikiContext);
        if (!result) throw new Error('Schema.org complex property matching failed');
    });

    // Á≠âÂæÖÊâÄÊúâÂºÇÊ≠•ÊµãËØïÂÆåÊàê
    setTimeout(() => {
        console.log('\nüìä Test Results Summary:');
        console.log(`Total Tests: ${testResults.total}`);
        console.log(`Passed: ${testResults.passed} ‚úÖ`);
        console.log(`Failed: ${testResults.failed} ‚ùå`);
        console.log(`Success Rate: ${((testResults.passed / testResults.total) * 100).toFixed(1)}%`);
        
        if (testResults.failed === 0) {
            console.log('\nüéâ All tests passed! Fixed matchers are working correctly.');
        } else {
            console.log('\n‚ö†Ô∏è  Some tests failed. Please check the implementation.');
        }
        
        process.exit(testResults.failed === 0 ? 0 : 1);
    }, 1000);
}

// ËøêË°åÊµãËØï
runTests().catch(error => {
    console.error('Test runner error:', error);
    process.exit(1);
});